# Increments can be unchecked
In Solidity 0.8+, there’s a default overflow check on unsigned integers. It’s possible to uncheck this in for-loops and save some gas at each iteration, but at the cost of some code readability, as this uncheck cannot be made inline. 

https://github.com/ethereum/solidity/issues/10695 


### Affected Code

```
File PoolApeStaking.sol
72:          for (uint256 index = 0; index < _nfts.length; index++)
103:         for (uint256 index = 0; index < _nfts.length; index++)
138:         for (uint256 index = 0; index < _nftPairs.length; index++)
172:         for (uint256 index = 0; index < actualTransferAmount; index++)
199:         for (uint256 index = 0; index < _nftPairs.length; index++)
215:         for (uint256 index = 0; index < _nftPairs.length; index++)
279:         for (uint256 index = 0; index < _nfts.length; index++)
289:         for (uint256 index = 0; index < _nftPairs.length; index++)
305:         for (uint256 index = 0; index < _nftPairs.length; index++)

File: UniswapV3OracleWrapper.sol
193:         for (uint256 index = 0; index < tokenIds.length; index++)
210:         for (uint256 index = 0; index < tokenIds.length; index++)

File: SupplyLogic.sol
185:         for (uint256 index = 0; index < params.tokenData.length; index++)
196:         for (uint256 index = 0; index < params.tokenData.length; index++)

File: ValidationLogic.sol
131:         for (uint256 index = 0; index < amount; index++)
212:         for (uint256 index = 0; index < tokenIds.length; index++)
465:         for (uint256 index = 0; index < tokenIds.length; index++)
465:         for (uint256 index = 0; index < tokenIds.length; index++)

File: GenericLogic.sol
371:         for (uint256 index = 0; index < totalBalance; index++)
466:         for (uint256 index = 0; index < totalBalance; index++)

File: ApeStakingLogic.sol
213:         for (uint256 index = 0; index < totalBalance; index++)

File: MintableERC721Logic.sol
207:         for (uint256 index = 0; index < tokenData.length; index++)
280:         for (uint256 index = 0; index < tokenIds.length; index++)

File: NToken.sol
106:         for (uint256 index = 0; index < tokenIds.length; index++)

File: NTokenApeStaking.sol
107:         for (uint256 index = 0; index < tokenIds.length; index++)

File: NTokenMoonBirds.sol
51:          for (uint256 index = 0; index < tokenIds.length; index++)
97:          for (uint256 index = 0; index < tokenIds.length; index++)

File: MintableIncentivizedERC721.sol
493:         for (uint256 index = 0; index < tokenIds.length; index++)
```

### Recommendation

The code would go from:

```
for (uint256 i; i < numIterations; ++i) {
 // ...  
}  
```

to:
``` 
for (uint256 i; i < numIterations;) {  
 // ...  
 unchecked { ++i; }
}  
```

The risk of overflow is inexistant for `uint256` here. And as it is everywhere, a lot of gas can be saved.

# X += Y costs more gas than X = X + Y

*There are 5 instances of this issue:*

```
File: UniswapV3OracleWrapper.sol
149:      token0Amount += positionData.tokensOwed0;
150:      token1Amount += positionData.tokensOwed1;
211:      sum += getTokenPrice(tokenIds[index]);
```
```
File: MarketplaceLogic.sol
397:      price += item.startAmount;
```
```
File: PoolApeStaking.sol
77:       amountToWithdraw += _nfts[index].amount;
166:      amountToWithdraw += _nftPairs[index].amount;
```
```
File: ApeStakingLogic.sol
215:      totalAmount += getTokenIdStakingAmount(
257:      apeStakedAmount += bakcStakedAmount;
```
```
File: GenericLogic.sol
169:      vars.payableDebtByERC20Assets += vars
                   .userBalanceInBaseCurrency
                   .percentDiv(vars.liquidationBonus);

176:      vars.avgLtv += vars.userBalanceInBaseCurrency * vars.ltv;

178:      vars.totalCollateralInBaseCurrency += vars
                   .userBalanceInBaseCurrency;

185:      vars.avgLiquidationThreshold += vars.liquidationThreshold;

189:      vars.totalDebtInBaseCurrency += _getUserDebtInBaseCurrency(
                   params.user,
                   currentReserve,
                   vars.assetPrice,
                   vars.assetUnit)

231:      vars.avgERC721LiquidationThreshold += vars
                   .liquidationThreshold;
233:      vars.totalERC721CollateralInBaseCurrency += vars
                    .userBalanceInBaseCurrency;
235:      vars.totalCollateralInBaseCurrency += vars
                    .userBalanceInBaseCurrency;
237:      vars.avgLtv += vars.ltv;
238:      vars.avgLiquidationThreshold += vars.liquidationThreshold;
```

# OR operator cost less gas than his equivalent AND operator

!(!a || !b) return same ouput as (a && b) and also consume less gas than the (a && b), doesn't matter even the 10k Optimizer enabled.

### Proof of Concept
Same has been pointed in opensea contest [G10](https://code4rena.com/reports/2022-05-opensea-seaport#g-10-or-conditions-cost-less-than-their-equivalent-and-conditions-notsomething-is-false-costs-less-than-everything-is-true).